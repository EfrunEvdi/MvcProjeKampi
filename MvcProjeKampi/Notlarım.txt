# 2 Ders (View Controller Ve Layout Kavramları)
Layout - View - Controller yapılarını daha iyi kavrayabilmek için yapıları tek tek oluşturup detaylandıralım.

" Controllers > Add > Controller... > MVC 5 Controller - Empty " adımlarını uygulayarak yeni bir tane CONTROLLER oluşturuyoruz.

Projede yer alan her bir menü alanı bir controller olarak tutulacaktır. (başlık, kullanıcılar, yazılar vb.) Burada amaç SOLID presiplerine göre hareket etmektir. 

SOLID yazılım prensipleri; geliştirilen yazılımın esnek, yeniden kullanılabilir, sürdürülebilir ve anlaşılır olmasını sağlayan, kod tekrarını önleyen prensipler bütünüdür.

S — Single responsibility principle : Bir sınıfın yapması gereken sadece bir işi olmalıdır.

O — Open closed principle : Bir sınıf ya da fonksiyon halihazırda var olan özellikleri korumalı ve değişikliğe izin vermemelidir.

L — Liskov substitution principle : Kodlarımızda herhangi bir değişiklik yapmaya gerek duymadan alt sınıfları, türedikleri(üst) sınıfların yerine kullanabilmeliyiz.

I — Interface segregation principle : Sorumlulukların hepsini tek bir arayüze toplamak yerine daha özelleştirilmiş birden fazla arayüz oluşturmalıyız.

D — Dependency Inversion Principle : Sınıflar arası bağımlılıklar olabildiğince az olmalıdır özellikle üst seviye sınıflar alt seviye sınıflara bağımlı olmamalıdır.

Oluşturulan Controller 'ın içinde bir tane "ActionResult" türünde index methodu hazır olarak gelir. Bu index metodunu bir VIEW oluşturmak için kullanacağız. Ancak öncelikle LAYOUT (sabit kalan alan) yapısını oluşturalım. 

"Shared > Add > View..." adımlarını uygulayarak yeni bir VIEW oluşturuyoruz. Bu View herhangi bir layout 'u kullanmayacak yani "use a layout page" checkbox 'ını seçmezsek View 'in kendisi bir layout olur. Oluşturduğumuz layout yapısını tarayıcıda çalıştırmak istediğimizde bize izin vermeyecektir. Projenin buradan çalıştırılabilmesi için bu sayfanın bir controller 'ının olması gerekir. Controller da ki ilgili .cs sayfasında index() metoduna sağ tık yapıp Add View diyoruz. Eklenecek olan View az önce oluşturduğumuz Layout  'u kullanacak. Bu nedenle checkbox ı işaretleyip "..." butonuna tıklayıp Shared klasöründen ilgili layout 'u seçelim ve View i ekleyelim. Artık oluşturduğumuz sayfada sağ tık > View in Browser diyerek projeyi tarayıcıda çalıştırabiliriz. Ancak ondan önce yapmamız gereken oluşturduğumuz layout 'a sayfaları yüklerken bu sayfaları layout 'un hangi kısmına yükleyeceğimizi belirtmemiz gerekiyor. Bu belirtme işlemini @RenderBody() metodunu kullanıyoruz.

‼️ Projenin HTML kısmında C# komutlarını kullanabilmek için ifadelerin başına @ sembolünü eklememiz gerekiyor.

# 3 Ders (Katmanların Oluşturulması)
Katmanlı mimari temelde 3 katmandan oluşmaktadır. Bu katmanlar genellik her projenizde olması gereken katmanlardır. ( Sunum - İş - Veri ) Geliştirici bu 3 katmandan daha fazla bir katmanlı yapıda oluşturabilir bu yapıya çok katmanlı mimari denilmektedir. 

1. Sunum Katmanı (Presentation Layer) : Kullanıcı ile etkileşimin yapıldığı katmandır. Burada temel amaç kullanıcıya verileri göstermek ve kullanıcıdan gelen verileri Business Katmanı ile Data Access’e iletmektir.
2. İş Katmanı (Business Layer) : Data Access  tarafında projeye çekilmiş olan veriler bu katmanda işlenir. Kullanıcıdan gelen veriler önce Business katmanına gider oradan da işlenerek Data Access katmanına aktarılır. Bu katmanda ayrıca bu verilere kimlerin erişeceğini belirtiyoruz. 
3. Veri Katmanı (Data Access Layer) : Bu katmanda ekleme (Create), okuma (Read), güncelleme (Update) ve silme (Delete) gibi veritabanı işlemleri yapılmaktadır. Bu dört temel işlem CRUD olarak ifade edilir.
4. Entity Layer : Veri tabanındaki tabloların ve içerisindeki sütunların tanımlanacağı ve bunların C# üzerinde class ve properties (özellikler) olarak ifade edileceği yapıların tutulduğu kısımdır.

Bu dört katmanı projemize ekleyelim. Eklenen her katman yeni bir proje ögesi olarak karşımıza gelecektir.

Solution alanına sağ tık > Add > New Project > Visual C# > Class Library (.NET Framework) adımlarını seçerek EntityLayer - DataAccessLayer - BusinessLayer katmanlarını sırasıyla oluşturalım. Oluşturduğumuz proje katmanları otomatik olarak "class1" isimin de bir class ile birlikte gelir. Biz bu class1 sınıfını silip kendi sınıflarımızı oluşturacağız.

Projeyi ilk oluşturduğumuzda karşımıza çıkan ilk katman aslında bizim Sunum Katmanımıza karşılık geliyor. Bu nedenle başlangıçta projeyi adlandırırken sonuna UI eklemek mantıklı bir yaklaşım olacaktır.

# 4 - 5 Ders (Entity Katmanı Sınıflarının Oluşturulması)
Entity katmanında oluşturacağımız tabloları ve onların özelliklerini belirtiyoruz.

Heading (Başlık) / Content (İçerik) / Writer (Yazar) / Contact (İletişim) / About (Hakkında) / Category (Kategori) 

EntityLayer sağ tık > Add > New Folder  diyerek "Concrete" isimli yeni bir klasör oluşturuyoruz. Bu klasörde SOMUT olarak tutulan ifadeler yer alacaktır. SOYUT olarak tutulan ifadeleri de ilerleyen adımlarda "Abstract" isimli klasör de tutacağız.

Concrete klasörüne sırası ile Heading / Content / Writer / Contact / About / Category sınıflarını ekliyoruz. Eklediğimiz sınıfların erişim belirleyicilerini (Access Modifiers) "public" yapmalıyız ki diğer alanlardan da erişim sağlanabilsin. 

Sırada oluşturduğumuz her sınıfın (properties) özelliklerini eklemek kaldı. prop yazıp tabx2 yaptığımızda properties formu otomatik olarak gelecektir.

# 6 Ders (İlişkilerin Oluşturulması 1)
İlişki oluşturmak içim Ctaegor sınıfında :

public ICollection<Heading> Headings { get; set; }

Heading sınıfında :

public int CategoryID { get; set; }
public virtual Category Category { get; set; }

propertylerini yazdık.

Daha sonra Heading sınıfına :

public ICollection<Content> Contents { get; set; }

Content sınıfına :

public int HeadingID { get; set; }
public virtual Heading Heading { get; set; }

yazarak ilişkileri oluşturduk.

# 7 Ders (İlişkilerin Oluşturulması 2)
Bu derste Writer tablosu ile Heading ve Writer tablolarını ilişkilendirdik.

# 8 Ders (Key Ve String Length Attributeleri)
-> EntityFramework (6.4.4) paketini EntityLayer'a kurduktan sonra [Key] ile primary key [StringLength] ile karakter sınırı tanımladık.

# 9 Ders (Context Sınıfı)
Bu derste ilk olarak DataAccessLayer'a
EntityFramework (6.4.4)
paketini yüklüyoruz. Devamında Concrete klasörünü içine Context sınıfını oluşturup DbSet propertilerini yazıyoruz.

# 10 Ders (Web Config Yapılandırması ve Bağlantı Ayarı)
Bu derste UI katmanındaki web.config klasörüne aşağıdaki kodu yazıyoruz.
<connectionStrings>
		<add name="Context" connectionString="data source=(localdb)\MSSQLLOCALDB; initial catalog=MvcKampDB; integrated security=true" providerName="System.Data.SqlClient"/>
</connectionStrings>

# 11 Ders (Migrations ve Veri Tabanının Oluşturulması)
Bu derste migration oluşturmak için önce enable-migration ardından update-database yaptık.

# 12 Ders (Add Migration İşlemi)
Bir önceki derste aldığımız hatayı int? yaptık ve add-migration ile güncellemeyi sql'e yansıttık.

# 13 Ders (Örnek SQL Veri Girişleri)
Sql'de veri girişi yaptık

# 14 Ders (Abstract Ve Interface Bileşenleri)
Bu derste DataAccessLayer içine Abstract klasörünü içine ICategoryDal interfaceini ekliyoruz.

# 15 Ders (Repository Sınıfı Ve Metotların İçinin Doldurulması)
DataAccessLayer'da Concrete klasörünü açıp içine CategoryRepository classını dahil edip doldurduk. Update'te sadece değişiklikleri kaydettik.

# 16 Ders (IRepository Interface)
Dal içine IWriterDal ı açtık ama DRY yüzünden bunun yanlış olduğunu biliyoruz. Bu yüzden IRepository'i ekleyip bunun içini doldurduk.

# 17 Ders (Generic Interface)
Bu derste Dal içindeki Abstract klasörüne tüm enityler için interface oluşturduk. Devamında WriterRepositoryi oluşturduk ama bunu da generic hale getireceğiz. 

# 18 Ders (Generic Repository)
Bu derste GenericRepositoryi oluşturup doldurduk ve dersi bitirdik.

# 19 Ders (Business Layer) 
BusinessLayer'a referans olarak DAL ve EL katmanlarını veriyoruz ve EntityFramework (6.4.4) paketini indiriyoruz. Ardıdnan Abstract ve Concrete klasörlerini bu katmana dahil ediyoruz. Concrete içine CategoryManager classını açıp içini dolduruyoruz ve dersi bitiriyoruz.

# 20 Ders (Tablo Kullanımı (Sertifika Görev 1/4))
Bu derste bir controller açık tablo yapısına değinildi.

# 21 Ders (Bootstrap)
Bu derste bootstrapten bahsedildi.

# 22 Ders (Kategorilerin Listelenmesi)
Bu derste ilk olarak UI katmanına diğer tüm katmanları referans verdik devamında EntityFramework (6.4.4) paketini indirdik ve CategoryController'a

 public ActionResult GetCategoryList()
        {
            var categoryvalues = cm.GelAllBL();
            return View(categoryvalues);
        }

yazdık ve bu sayfaya ait viewi açarak table yapısı ve foeach döngüsü ile verileri listelettik.

# 23 Ders (Break Point)
Bu derste breakpoint ile işlem yapmayı öğrendik.

# 24 Ders (Yeni Kategori Ekleme)
Bu derste kategori nasıl eklenmez onu öğrendik. :D

# 25 Ders (HttpGet ve HttpPost Attributeleri)
Bu derste yeni kategori ekleme sayfasını öğrendik.

# 26 Ders (Ekleme Hataları)
Bu derste Manager'daki hatalara baktık.

# 27 Ders (Business Abstract & ICategoryService)
Bu derste ilk olarak ICategoryService adlı interfacei Business/Abstract içine dahil ediyoruz. İçini doldurduk.

# 28 Ders (Constructor Business Metot)

Dependency Injection (Bağımlılık Enjeksiyonu), bir yazılım tasarım desenidir ve nesne yönelimli programlamada kullanılır. Bu desen, bir nesnenin bağımlı olduğu diğer nesneleri dışarıdan sağlanmasını sağlar, böylece bağımlılıkların esnek bir şekilde yönetilmesini ve test edilmesini kolaylaştırır.

Bağımlılık enjeksiyonu, bir nesnenin bağımlı olduğu diğer nesneleri parametreler veya setter metotları aracılığıyla dışarıdan almasını sağlar. Bu şekilde, bir nesne, bağımlı olduğu nesneleri doğrudan yaratmak veya başlatmak zorunda kalmaz. Bunun yerine, bağımlılıklar dışarıdan enjekte edilir ve nesne bu enjekte edilmiş bağımlılıkları kullanır.

Bağımlılık enjeksiyonu, yazılımın daha modüler, esnek ve test edilebilir olmasını sağlar. Bağımlılıkların dışarıdan enjekte edilebilmesi, nesneler arasındaki sıkı bağlantıyı azaltır ve bileşenlerin daha bağımsız hale gelmesini sağlar. Ayrıca, bağımlılıkların sahte veya taklit edilmiş nesnelerle değiştirilebilmesi, birim testlerin kolayca yapılabilmesini sağlar.

Bağımlılık enjeksiyonu, genellikle bağımlılıkları arayüzler veya soyut sınıflar üzerinden tanımlayarak ve bağımlılıkları enjekte eden bir "bağımlılık enjektörü" veya "konteyner" kullanarak gerçekleştirilir. Bağımlılık enjeksiyonu, Java, C#, PHP gibi birçok nesne yönelimli programlama dilinde yaygın olarak kullanılan bir desendir.

Bu derste Dal içine EntityFraweork'u dahil ederek dersi bitirdik.

# 29 Ders (EntityFramework Dal)
Bu derste tüm entityler için Ef klasöründe gerekli classları açtık ve categoyleri listelettik

# 30 Ders (FluentValidation)
Bu derste Business/ValidationRules/CategoryValidator u doldurduk.

# 31 Ders (Validasyon İşlemi)
Bu derste categoryadd işlemini validation ile controller'a tanımladık.

# 32 Ders (Validation Messagefor ile Validator Sınıfındaki Mesajların UI'da Listelenmesi)
Bu derste view tarafında kuralları gösterttik.

# 33 Ders (Temanın Yüklenmesi)
Bu derste projeye admin templateini yükledik.

# 34 Ders (Temanın Düzenlenmesi)
Bu derste projenin layotunu ayarladık.

# 35 Ders (Sidebar'da Son Düzenlemeler)
Bu derste navbar ve ikonları yaptık.

# 36 Ders (Sidebar ile Beraber Kategori İşlemleri)
Bu derste admin panelindeki categoryleri listeleme ve ekleme işlemlerini yaptık.

# 37 Ders (GetByID)
Bu derste category silebilmek için IRepository, GenericRepository ve Business katmanlarına GetByID için gerekli kodları yazdık.

# 38 Ders (Kategori Silme İşlemi)
Bu derste kategori silme işlemini tamamladık.

# 39 Ders (Güncellenecek Bilgilerin Getirilmesi)
Bu derste güncellenecek veriyi getirdik

# 40 Ders (Güncelleme İşlemi & Sertifika Görevi)
Bu derste güncelleme kısmının post tarfını yapıp istatistik ödevini yaptık.

# 41 Ders (Entity State Komutları)
Bu derste GenericRepository i state komutları ile güncelledik.

# 42 Ders (Yazar İşlemleri)
Bu derste yazar işlemleri için her şeyden önce BusinessLayerdaki IWriterService ve WriterManager sınıflarını ekledik ve doldurduk. Devamında tüm yazarları table yapısı ile listelettik.

# 43 Ders (Yazar Profilleri Listesi)
Bu derste yazar listesi güzelleştirdik.

# 44 Ders (Add Migration & Yazar İşlemleri Devamı)
Bu derste yazar entitysini güncelledik ve index tarafında güncellemeler yaptık.

# 45 Ders (Yazar İşlemlerinin Tamamlanması)
Bu derste yazar güncelleme sayfasını

# 46 Ders (Başlık İşlemleri)
Bu derste Başlıkları listeletme işlerini yaptık.

# 47 Ders (Başlık İşlemlerinde DropDownList ve İlişki Kullanımı)
Bu derste başlık eklerken kategorileri listelenmek için aşağıdaki kodu yazdık.

[HttpGet]
  public ActionResult AddHeading()
  {
      List<SelectListItem> ValueCategory = (from x in cm.GetList()
                                            select new SelectListItem
                                            {
                                                Text = x.CategoryName,
                                                Value = x.CategoryID.ToString()
                                            }).ToList();
      return View();
  }

# 48 Ders (Başlıklarda Oluşturulan Yazar ve Kategori İşlemleri)
Bu derste bir önceki ders yaptığımız kodun çekme işmeini aşağıdaki kodla yaptık.
 <label for="">Kategori</label>
    @Html.DropDownListFor(x => x.CategoryID, (List<SelectListItem>)ViewBag.VLC, "Kategori seçiniz.", new { @class = "form-control", @required = "required" })
    @Html.ValidationMessageFor(x => x.CategoryID)


# 49 Ders (Başlık İşlemleri)
Bu derste başlık kısmının templatini değiştirim düzenledik.

# 50 Ders  (Başlık Düzenlemeleri)
Bu derste başlık kısmıyla ilgilendik.
Tarih Formatı : @(((DateTime)item.HeadingDate).ToString("dd-MMMM-yyyy")

# 51 Ders (Content By Heading Sayfası)
